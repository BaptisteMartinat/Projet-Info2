#include "Badland.h"
#include <stdio.h>
#include <string.h>
#include <time.h>

void initialisation_allegro() {
    allegro_init();
    install_keyboard();
    install_mouse();
    set_color_depth(desktop_color_depth());
    if (set_gfx_mode(GFX_AUTODETECT_WINDOWED, SCREEN_W, SCREEN_H, 0, 0) != 0) {
        allegro_message("Problème mode graphique");
        exit(EXIT_FAILURE);
    }
}

void init_jeu(Joueur *joueur) {
    joueur->x = 100;
    joueur->y = SCREEN_H / 2;
    joueur->largeur = 40;
    joueur->hauteur = 40;
    joueur->dy = 0;
    joueur->dx = 0;
}

int charger_ressources(BITMAP **fond, BITMAP **collision_map, BITMAP **sprite1,
                       BITMAP **sprite2, BITMAP **img_gros, BITMAP *roues[4], BITMAP **img_petit) {
    *fond = load_bitmap("grotte_lave.bmp", NULL);
    *collision_map = load_bitmap("grotte_lave_colli.bmp", NULL);
    *sprite1 = load_bitmap("personnage1.bmp", NULL);
    *sprite2 = load_bitmap("personnage2.bmp", NULL);
    *img_gros = load_bitmap("gros.bmp", NULL);
    *img_petit = load_bitmap("petit.bmp", NULL);

    for (int i = 0; i < 4; i++) {
        char filename[20];
        sprintf(filename, "roue%d.bmp", i);
        roues[i] = load_bitmap(filename, NULL);
        if (!roues[i]) {
            allegro_message("Erreur chargement %s", filename);
            return 0;
        }
    }

    if (!*fond || !*sprite1 || !*sprite2 || !*collision_map || !*img_gros || !*img_petit) {
        allegro_message("Erreur chargement ressources !");
        return 0;
    }
    return 1;
}
nt detecter_arrivee(BITMAP *map, int cx, int cy, int rayon, int scroll) {
    for (int dx = -rayon; dx <= rayon; dx++) {
        for (int dy = -rayon; dy <= rayon; dy++) {
            if (dx * dx + dy * dy <= rayon * rayon) {
                int x = cx + dx + scroll;
                int y = cy + dy;
                if (x >= 0 && x < map->w && y >= 0 && y < map->h) {
                    if (getpixel(map, x, y) == makecol(0, 255, 0)) return 1;
                }
            }
        }
    }
    return 0;
}

// 3. Animation des roues
void maj_roues(Roue roues[], int *timer) {
    (*timer)++;
    if (*timer % 6 == 0) {
        for (int i = 0; i < NB_ROUES; i++) {
            roues[i].frame = (roues[i].frame + 1) % 4;
        }
    }
}

// 4. Collision roue avec checkpoint
void gestion_collision_roues(Joueur *joueur, Roue roues[], int nb, int *decor_scroll, Checkpoint checkpoints[], int dernier_cp) {
    for (int i = 0; i < nb; i++) {
        int rx = roues[i].x - *decor_scroll;
        int ry = roues[i].y;
        int jx = joueur->x + joueur->largeur / 2;
        int jy = joueur->y + joueur->hauteur / 2;
        int dx = jx - rx;
        int dy = jy - ry;
        if (dx * dx + dy * dy < 130 * 130) {
            if (dernier_cp != -1) {
                allegro_message("Tu as touché une roue ! Reprise depuis le dernier checkpoint.");
                joueur->x = checkpoints[dernier_cp].x;
                joueur->y = checkpoints[dernier_cp].y;
                *decor_scroll = checkpoints[dernier_cp].scroll;
                joueur->dy = joueur->dx = 0;
            } else {
                allegro_message("Tu es mort ! Aucun checkpoint atteint. Retour au menu.");
                menu_principal();
                return;
            }
        }
    }
}

// 5. Checkpoints
int joueur_sur_checkpoint(Joueur *joueur, int cp_x, int cp_y, int scroll, int sw, int sh) {
    int jx1 = joueur->x, jy1 = joueur->y;
    int jx2 = jx1 + joueur->largeur;
    int jy2 = jy1 + joueur->hauteur;
    int cx1 = cp_x - scroll, cy1 = cp_y - sh;
    int cx2 = cx1 + sw, cy2 = cy1 + sh;
    return !(jx2 < cx1 || jx1 > cx2 || jy2 < cy1 || jy1 > cy2);
}

void maj_checkpoints(Joueur *joueur, Checkpoint checkpoints[], const int positions[][2], int *dernier_cp, int decor_scroll, BITMAP *sprite) {
    for (int i = 0; i < NB_CHECKPOINTS; i++) {
        if (!checkpoints[i].actif && joueur_sur_checkpoint(joueur, positions[i][0], positions[i][1], decor_scroll, sprite->w, sprite->h)) {
            checkpoints[i].x = joueur->x;
            checkpoints[i].y = joueur->y;
            checkpoints[i].scroll = decor_scroll;
            checkpoints[i].actif = 1;
            *dernier_cp = i;
            char msg[50];
            sprintf(msg, "Checkpoint %d activé !", i + 1);
            allegro_message(msg);
        }
    }
}


void gerer_saut(Joueur *joueur, int *sprite_state, int *timerinterne) {
    if (keypressed() && (readkey() >> 8) == KEY_SPACE) {
        *sprite_state = 1;
        *timerinterne = 10;
        joueur->dy = JUMP_STRENGTH;
    }
    if (*timerinterne > 0) {
        (*timerinterne)--;
        if (*timerinterne == 0) *sprite_state = 0;
    }
}

void appliquer_physique(Joueur *joueur) {
    joueur->dy += GRAVITY;
}

int verifier_collision_roue(Joueur *joueur, BITMAP *roue, int roue_x, int roue_y, int decor_scroll) {
    int roue_largeur = roue->w;
    int roue_hauteur = roue->h;
    int roue_x_ecran = roue_x - decor_scroll;

    return collision(joueur->x, joueur->y, joueur->largeur, joueur->hauteur,
                     roue_x_ecran, roue_y, roue_largeur, roue_hauteur);
}

void gerer_collisions(Joueur *joueur, BITMAP *collision_map, int decor_scroll) {
    // Horizontal
    int try_x = joueur->x + 1;
    int can_move_x = 1;
    for (int i = 0; i < joueur->largeur && can_move_x; i++) {
        for (int j = 0; j < joueur->hauteur; j++) {
            int gx = try_x + i + decor_scroll;
            int gy = joueur->y + j;
            if (gx < collision_map->w && gy < collision_map->h &&
                getpixel(collision_map, gx, gy) == makecol(0, 0, 0)) {
                can_move_x = 0;
                break;
            }
        }
    }
    if (can_move_x) joueur->x += 1;
    else {
        int pushed;
        do {
            pushed = 0;
            for (int i = 0; i < joueur->largeur && !pushed; i++) {
                for (int j = 0; j < joueur->hauteur && !pushed; j++) {
                    int gx = joueur->x + i + decor_scroll;
                    int gy = joueur->y + j;
                    if (gx < collision_map->w && gy < collision_map->h &&
                        getpixel(collision_map, gx, gy) == makecol(0, 0, 0)) {
                        joueur->x -= 1;
                        pushed = 1;
                    }
                }
            }
        } while (pushed && joueur->x > 0);
    }

    // Vertical
    int try_y = joueur->y + joueur->dy;
    int can_move_y = 1;
    for (int i = 0; i < joueur->largeur && can_move_y; i++) {
        for (int j = 0; j < joueur->hauteur; j++) {
            int gx = joueur->x + i + decor_scroll;
            int gy = try_y + j;
            if (gx < collision_map->w && gy < collision_map->h &&
                getpixel(collision_map, gx, gy) == makecol(0, 0, 0)) {
                can_move_y = 0;
                break;
            }
        }
    }
    if (can_move_y) joueur->y += joueur->dy;
    else joueur->dy = 0;

    // Limites verticales
    if (joueur->y < 10) {
        joueur->y = 10;
        joueur->dy = 0;
    }
    if (joueur->y + joueur->hauteur > SCREEN_H - 10) {
        joueur->y = SCREEN_H - joueur->hauteur - 10;
        joueur->dy = 0;
    }
}

int collision(int x1, int y1, int w1, int h1, int x2, int y2, int w2, int h2) {
    return x1 + w1 > x2 && x1 < x2 + w2 && y1 + h1 > y2 && y1 < y2 + h2;
}

void afficher_scene(BITMAP *page, BITMAP *fond, BITMAP *sprite1, BITMAP *sprite2,
                    BITMAP *roues[], int etape_roue, Joueur *joueur, int sprite_state,
                    float facteur_perso, int decor_scroll, int temps_actuel,
                    int afficher_gros, int gros_collision, BITMAP *img_gros,
                    int gros_x, int gros_y, int afficher_petit, int petit_collision, BITMAP *img_petit,
                    int petit_x, int petit_y) {
    clear_bitmap(page);
    blit(fond, page, decor_scroll, 0, 0, 0, SCREEN_W, SCREEN_H);

    masked_blit(roues[etape_roue], page, 0, 0,
                800 - decor_scroll, 300,
                roues[etape_roue]->w, roues[etape_roue]->h);

    if (afficher_gros && !gros_collision) {
        draw_sprite(page, img_gros, gros_x - decor_scroll, gros_y);
    }

    if (afficher_petit && !petit_collision) {
        draw_sprite(page, img_petit, petit_x - decor_scroll, petit_y);
    }

    BITMAP *sprite = sprite_state ? sprite2 : sprite1;
    int largeur = joueur->largeur * facteur_perso;
    int hauteur = joueur->hauteur * facteur_perso;
    stretch_sprite(page, sprite, joueur->x, joueur->y, largeur, hauteur);

    char buffer[50];
    sprintf(buffer, "Temps : %d s", temps_actuel);
    textout_ex(page, font, buffer, 10, 10, makecol(255, 255, 255), -1);

    blit(page, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
}

void nettoyer_ressources(BITMAP *fond, BITMAP *collision_map, BITMAP *sprite1,
                         BITMAP *sprite2, BITMAP *img_gros, BITMAP *img_petit, BITMAP *roues[], BITMAP *page) {
    destroy_bitmap(fond);
    destroy_bitmap(collision_map);
    destroy_bitmap(sprite1);
    destroy_bitmap(sprite2);
    destroy_bitmap(img_gros);
    destroy_bitmap(img_petit);
    destroy_bitmap(page);
    for (int i = 0; i < 4; i++) destroy_bitmap(roues[i]);
}

void jeu_scrolling(const char *pseudo) {
    Joueur joueur;
    int decor_scroll = 0;
    BITMAP *page = create_bitmap(SCREEN_W, SCREEN_H);
    BITMAP *fond, *collision_map, *sprite1, *sprite2, *img_gros, *img_petit;
    BITMAP *roues[4];

    if (!charger_ressources(&fond, &collision_map, &sprite1, &sprite2, &img_gros, roues, &img_petit)) return;

    int temps_depart = clock();
    int timerinterne = 0;
    int afficher_gros = 0;
    int afficher_petit = 0;
    int gros_collision = 0;
    int petit_collision = 0;
    float facteur_perso = 1.0;
    int gros_x = 1500, gros_y = 300;
    int gros_largeur = img_gros->w, gros_hauteur = img_gros->h;
    int petit_x = 2000, petit_y = 350;
    int petit_largeur = img_petit->w, petit_hauteur = img_petit->h;
    int etape_roue = 0, dernier_changement_roue = 0;
    int roue_x = 800, roue_y = 300;

    init_jeu(&joueur);
    strcpy(joueur.nom, pseudo);
    joueur.niveau = 1;
    int sprite_state = 0;

    while (!key[KEY_ESC]) {
        int temps_actuel = (clock() - temps_depart) / CLOCKS_PER_SEC;

        gerer_roues(&etape_roue, &dernier_changement_roue, temps_actuel);
        gerer_saut(&joueur, &sprite_state, &timerinterne);
        appliquer_physique(&joueur);

        if (verifier_collision_roue(&joueur, roues[etape_roue], roue_x, roue_y, decor_scroll)) {
            allegro_message("Game Over - Vous avez touché la roue !");
            break;
        }

        gerer_collisions(&joueur, collision_map, decor_scroll);

        if (joueur.x + joueur.largeur < 0) {
            allegro_message("GAME OVER - Vous êtes sorti de l'écran !");
            break;
        }

        decor_scroll += DECOR_SCROLL_SPEED;

        if (temps_actuel >= 4) afficher_gros = 1;
        if (temps_actuel >= 12) afficher_petit = 1;

        if (afficher_gros && !gros_collision) {
            int gros_x_ecran = gros_x - decor_scroll;
            if (collision(joueur.x, joueur.y, joueur.largeur, joueur.hauteur,
                          gros_x_ecran, gros_y, gros_largeur, gros_hauteur)) {
                gros_collision = 1;
            }
        }

        if (gros_collision) {
            if (facteur_perso < 1.5) {
                facteur_perso = 1.5;

                int ancien_largeur = joueur.largeur;
                int ancien_hauteur = joueur.hauteur;

                joueur.largeur = 40 * facteur_perso;
                joueur.hauteur = 40 * facteur_perso;

                joueur.x -= (joueur.largeur - ancien_largeur) / 2;
                joueur.y -= (joueur.hauteur - ancien_hauteur) / 2;
            }
        }


        if (afficher_petit && !petit_collision) {
            int petit_x_ecran = petit_x - decor_scroll;
            if (collision(joueur.x, joueur.y, joueur.largeur, joueur.hauteur,
                          petit_x_ecran, petit_y, petit_largeur, petit_hauteur)) {
                petit_collision = 1;
                          }
        }

        if (petit_collision) {
            if (facteur_perso > 0.8) {
                facteur_perso = 0.8;

                int ancien_largeur = joueur.largeur;
                int ancien_hauteur = joueur.hauteur;

                joueur.largeur = 40 * facteur_perso;
                joueur.hauteur = 40 * facteur_perso;

                joueur.x -= (joueur.largeur - ancien_largeur) / 2;
                joueur.y -= (joueur.hauteur - ancien_hauteur) / 2;
            }
        }


        afficher_scene(page, fond, sprite1, sprite2, roues, etape_roue, &joueur, sprite_state,
                       facteur_perso, decor_scroll, temps_actuel, afficher_gros,
                       gros_collision, img_gros, gros_x, gros_y, afficher_petit,
                       petit_collision, img_petit, petit_x, petit_y);

        rest(20);
    }

    nettoyer_ressources(fond, collision_map, sprite1, sprite2, img_gros, roues, page, img_petit);
}


void menu_principal() {
    BITMAP *buffer = create_bitmap(SCREEN_W, SCREEN_H);
    BITMAP *fondmenu = load_bitmap("fondmenu.bmp", NULL);
    BITMAP *marbre = load_bitmap("marbre.bmp", NULL);
    BITMAP *img_volcan = load_bitmap("volcan.bmp", NULL);
    BITMAP *img_montagne = load_bitmap("montagne.bmp", NULL);
    BITMAP *img_mer = load_bitmap("mer.bmp", NULL);

    if (!fondmenu || !marbre || !img_volcan || !img_montagne || !img_mer) {
        allegro_message("Erreur chargement images menu.");
        return;
    }

    char pseudo[MAX_NAME_LENGTH] = "";
    int etape_menu = 0; // 0 = pseudo, 1 = boutons, 2 = maps
    int pseudo_index = 0;

    while (!key[KEY_ESC]) {
        clear(buffer);
        stretch_blit(fondmenu, buffer, 0, 0, fondmenu->w, fondmenu->h, 0, 0, SCREEN_W, SCREEN_H);
        textout_centre_ex(buffer, font, "==== BADLAND ====", SCREEN_W / 2, 30, makecol(255, 215, 0), -1);

        if (etape_menu == 0) {
            // =========== SAISIE PSEUDO ===========
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, 200, 160, 400, 200);
            rect(buffer, 200, 160, 600, 360, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "RENTRER PSEUDO", 400, 180, makecol(0, 0, 0), -1);
            rectfill(buffer, 250, 220, 550, 260, makecol(255, 230, 220));
            rect(buffer, 250, 220, 550, 260, makecol(0, 0, 0));
            textprintf_ex(buffer, font, 260, 235, makecol(0, 0, 0), -1, "%s", pseudo);

            int ok_x1 = 350, ok_y1 = 290, ok_x2 = 450, ok_y2 = 320;
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, ok_x1, ok_y1, ok_x2 - ok_x1, ok_y2 - ok_y1);
            rect(buffer, ok_x1, ok_y1, ok_x2, ok_y2, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "OK", 400, 300, makecol(0, 0, 0), -1);

            if (keypressed()) {
                int key_code = readkey();
                int k = key_code >> 8;
                char ch = key_code & 0xff;
                if (k == KEY_ENTER && pseudo_index > 0) etape_menu = 1;
                else if (k == KEY_BACKSPACE && pseudo_index > 0) pseudo[--pseudo_index] = '\0';
                else if (pseudo_index < MAX_NAME_LENGTH - 1 && ch >= 32 && ch <= 126) {
                    pseudo[pseudo_index++] = ch;
                    pseudo[pseudo_index] = '\0';
                }
            }

            if (mouse_b & 1 &&
                mouse_x >= ok_x1 && mouse_x <= ok_x2 &&
                mouse_y >= ok_y1 && mouse_y <= ok_y2 &&
                pseudo_index > 0) {
                etape_menu = 1;
                rest(200);
            }

        } else if (etape_menu == 1) {
            // ========== BOUTONS NOUVELLE / CHARGER ==========
            textprintf_ex(buffer, font, 10, 40, makecol(255, 255, 255), -1, "Joueur: %s", pseudo);
            textout_centre_ex(buffer, font, "Que veux-tu faire ?", SCREEN_W / 2, 80, makecol(255, 255, 255), -1);

            int btn_w = 250, btn_h = 80;
            int btn_x = (SCREEN_W - btn_w) / 2;
            int btn_y1 = 180;
            int btn_y2 = 300;

            // Fond marbre + texte
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, btn_x, btn_y1, btn_w, btn_h);
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, btn_x, btn_y2, btn_w, btn_h);
            rect(buffer, btn_x, btn_y1, btn_x + btn_w, btn_y1 + btn_h, makecol(0, 0, 0));
            rect(buffer, btn_x, btn_y2, btn_x + btn_w, btn_y2 + btn_h, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "Nouvelle Partie", SCREEN_W / 2, btn_y1 + 30, makecol(0, 0, 0), -1);
            textout_centre_ex(buffer, font, "Charger Partie", SCREEN_W / 2, btn_y2 + 30, makecol(0, 0, 0), -1);

            // ==== BOUTONS RETOUR ET QUITTER ====
            int btn_ctrl_w = 100, btn_ctrl_h = 40;
            int retour_x = 20, retour_y = SCREEN_H - 60;
            int quit_x = SCREEN_W - 120, quit_y = SCREEN_H - 60;

            // Bouton Retour
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, retour_x, retour_y, btn_ctrl_w, btn_ctrl_h);
            rect(buffer, retour_x, retour_y, retour_x + btn_ctrl_w, retour_y + btn_ctrl_h, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "< Retour", retour_x + btn_ctrl_w / 2, retour_y + 12, makecol(0, 0, 0), -1);

            // Bouton Quitter
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, quit_x, quit_y, btn_ctrl_w, btn_ctrl_h);
            rect(buffer, quit_x, quit_y, quit_x + btn_ctrl_w, quit_y + btn_ctrl_h, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "Quitter", quit_x + btn_ctrl_w / 2, quit_y + 12, makecol(0, 0, 0), -1);
            // Gestion clic
            if (mouse_b & 1) {
                rest(200);
                // Nouvelle Partie
                if (mouse_x >= btn_x && mouse_x <= btn_x + btn_w &&
                    mouse_y >= btn_y1 && mouse_y <= btn_y1 + btn_h) {
                    etape_menu = 2;
                }
                // Charger Partie
                else if (mouse_x >= btn_x && mouse_x <= btn_x + btn_w &&
                         mouse_y >= btn_y2 && mouse_y <= btn_y2 + btn_h) {
                    allegro_message("Chargement de partie non disponible.");
                }
                // Retour
                else if (mouse_x >= retour_x && mouse_x <= retour_x + btn_ctrl_w &&
                         mouse_y >= retour_y && mouse_y <= retour_y + btn_ctrl_h) {
                    etape_menu = 0;
                }
                // Quitter
                else if (mouse_x >= quit_x && mouse_x <= quit_x + btn_ctrl_w &&
                         mouse_y >= quit_y && mouse_y <= quit_y + btn_ctrl_h) {
                    break;
                }
            }

        } else if (etape_menu == 2) {
            // ========== CHOIX MAPS (inchangé) ==========
            textprintf_ex(buffer, font, 10, 40, makecol(255, 255, 255), -1, "Joueur: %s", pseudo);
            textout_centre_ex(buffer, font, "Choisis un environnement :", SCREEN_W / 2, 80, makecol(255, 255, 255), -1);

            int cadre_w = 220, cadre_h = 300;
            int img_w = 200, img_h = 280;
            int img_y = 130;
            int space = 40;
            int start_x = (SCREEN_W - (3 * cadre_w + 2 * space)) / 2;

            // VOLCAN
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, start_x, img_y, cadre_w, cadre_h);
            stretch_blit(img_volcan, buffer, 0, 0, img_volcan->w, img_volcan->h,
                         start_x + (cadre_w - img_w) / 2, img_y + (cadre_h - img_h) / 2, img_w, img_h);
            textout_centre_ex(buffer, font, "Terre de Feu", start_x + cadre_w / 2, img_y + cadre_h + 10, makecol(255, 255, 255), -1);

            // MONTAGNE
            int mx = start_x + cadre_w + space;
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, mx, img_y, cadre_w, cadre_h);
            stretch_blit(img_montagne, buffer, 0, 0, img_montagne->w, img_montagne->h,
                         mx + (cadre_w - img_w) / 2, img_y + (cadre_h - img_h) / 2, img_w, img_h);
            textout_centre_ex(buffer, font, "Pics Silencieux", mx + cadre_w / 2, img_y + cadre_h + 10, makecol(255, 255, 255), -1);

            // MER
            int merx = start_x + 2 * (cadre_w + space);
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, merx, img_y, cadre_w, cadre_h);
            stretch_blit(img_mer, buffer, 0, 0, img_mer->w, img_mer->h,
                         merx + (cadre_w - img_w) / 2, img_y + (cadre_h - img_h) / 2, img_w, img_h);
            textout_centre_ex(buffer, font, "Rivages Perdus", merx + cadre_w / 2, img_y + cadre_h + 10, makecol(255, 255, 255), -1);

            // ==== BOUTONS RETOUR ET QUITTER ====
            int btn_ctrl_w = 100, btn_ctrl_h = 40;
            int retour_x = 20, retour_y = SCREEN_H - 60;
            int quit_x = SCREEN_W - 120, quit_y = SCREEN_H - 60;

            // Bouton Retour
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, retour_x, retour_y, btn_ctrl_w, btn_ctrl_h);
            rect(buffer, retour_x, retour_y, retour_x + btn_ctrl_w, retour_y + btn_ctrl_h, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "< Retour", retour_x + btn_ctrl_w / 2, retour_y + 12, makecol(0, 0, 0), -1);

            // Bouton Quitter
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, quit_x, quit_y, btn_ctrl_w, btn_ctrl_h);
            rect(buffer, quit_x, quit_y, quit_x + btn_ctrl_w, quit_y + btn_ctrl_h, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "Quitter", quit_x + btn_ctrl_w / 2, quit_y + 12, makecol(0, 0, 0), -1);

            // CLIC MAP
            if (mouse_b & 1) {
                rest(200);
                if (mouse_x >= start_x && mouse_x <= start_x + cadre_w &&
                    mouse_y >= img_y && mouse_y <= img_y + cadre_h) {
                    jeu_scrolling(pseudo);
                } else if (mouse_x >= mx && mouse_x <= mx + cadre_w &&
                           mouse_y >= img_y && mouse_y <= img_y + cadre_h) {
                    allegro_message("Montagne pas encore disponible !");
                } else if (mouse_x >= merx && mouse_x <= merx + cadre_w &&
                           mouse_y >= img_y && mouse_y <= img_y + cadre_h) {
                    allegro_message("Mer pas encore disponible !");
                }
                // Retour
                if (mouse_x >= retour_x && mouse_x <= retour_x + btn_ctrl_w &&
                    mouse_y >= retour_y && mouse_y <= retour_y + btn_ctrl_h) {
                    etape_menu = 1;
                }
                // Quitter
                if (mouse_x >= quit_x && mouse_x <= quit_x + btn_ctrl_w &&
                    mouse_y >= quit_y && mouse_y <= quit_y + btn_ctrl_h) {
                    break;
                }
            }
        }

        blit(buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
        rest(1);
    }

    destroy_bitmap(fondmenu);
    destroy_bitmap(marbre);
    destroy_bitmap(img_volcan);
    destroy_bitmap(img_montagne);
    destroy_bitmap(img_mer);
    destroy_bitmap(buffer);
}
