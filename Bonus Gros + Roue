#include "Badland.h"
#include <stdio.h>
#include <string.h>
#include <time.h>

void initialisation_allegro() {
    allegro_init();
    install_keyboard();
    install_mouse();
    set_color_depth(desktop_color_depth());
    if (set_gfx_mode(GFX_AUTODETECT_WINDOWED, SCREEN_W, SCREEN_H, 0, 0) != 0) {
        allegro_message("Problème mode graphique");
        exit(EXIT_FAILURE);
    }
}

void init_jeu(Joueur *joueur) {
    joueur->x = 100;
    joueur->y = SCREEN_H / 2;
    joueur->largeur = 40;
    joueur->hauteur = 40;
    joueur->dy = 0;
    joueur->dx = 0;
}

void jeu_scrolling(const char *pseudo) {
    Joueur joueur;
    int decor_scroll = 0;
    BITMAP *page = create_bitmap(SCREEN_W, SCREEN_H);
    BITMAP *fond = load_bitmap("grotte_lave.bmp", NULL);
    BITMAP *collision_map = load_bitmap("grotte_lave_colli.bmp", NULL);
    BITMAP *sprite1 = load_bitmap("personnage1.bmp", NULL);
    BITMAP *sprite2 = load_bitmap("personnage2.bmp", NULL);
    BITMAP *img_gros = load_bitmap("gros.bmp", NULL);

    BITMAP *roues[4];
    for(int i=0; i<4; i++) {
        char filename[20];
        sprintf(filename, "roue%d.bmp", i);
        roues[i] = load_bitmap(filename, NULL);
        if(!roues[i]) {
            allegro_message("Erreur chargement %s", filename);
            return;
        }
    }

    int temps_depart = clock();
    int timerinterne = 0;

    if (!fond || !sprite1 || !sprite2 || !collision_map || !img_gros) {
        allegro_message("Erreur chargement ressources !");
        return;
    }
    /* Variables pour l'affichage de l'image "gros.bmp" après 10 secondes
       et pour l'agrandissement du personnage lors de la collision */
    int afficher_gros = 0;
    int gros_collision = 0;
    float facteur_perso = 1.0;
    int gros_x = 1500;
    int gros_y = 300;
    int gros_largeur = img_gros->w;
    int gros_hauteur = img_gros->h;

    /* Variables pour les roues */
    int etape_roue = 0;
    int dernier_changement_roue = 0;
    int roue_x = 800;  // Position x des roues
    int roue_y = 300;   // Position y des roues

    init_jeu(&joueur);
    strcpy(joueur.nom, pseudo);
    joueur.niveau = 1;
    int sprite_state = 0;

    while (!key[KEY_ESC]) {
        int temps_actuel = (clock() - temps_depart) / CLOCKS_PER_SEC;

        // Gestion des roues toutes les 10 secondes
        if(temps_actuel - dernier_changement_roue >= 0.5) {
            etape_roue = (etape_roue + 1) % 4;
            dernier_changement_roue = temps_actuel;
        }

        // Gestion du saut
        if (keypressed() && (readkey() >> 8) == KEY_SPACE) {
            sprite_state = 1;
            timerinterne = 10;
            joueur.dy = JUMP_STRENGTH;
        }
        if (timerinterne > 0) {
            timerinterne--;
            if (timerinterne == 0) sprite_state = 0;
        }

        // Physique du jeu
        joueur.dy += GRAVITY;

        int roue_largeur = roues[etape_roue]->w;
        int roue_hauteur = roues[etape_roue]->h;
        int roue_x_ecran = roue_x - decor_scroll;

        if (joueur.x + joueur.largeur > roue_x_ecran &&
            joueur.x < roue_x_ecran + roue_largeur &&
            joueur.y + joueur.hauteur > roue_y &&
            joueur.y < roue_y + roue_hauteur) {
            allegro_message("Game Over - Vous avez touché la roue !");
            return; // Quitte la fonction pour revenir au menu
            }

                // === Collision horizontale ===
        int try_x = joueur.x + 1;
        int can_move_x = 1;
        for (int i = 0; i < joueur.largeur; i++) {
            for (int j = 0; j < joueur.hauteur; j++) {
                int gx = try_x + i + decor_scroll;
                int gy = joueur.y + j;
                if (gx >= 0 && gx < collision_map->w &&
                    gy >= 0 && gy < collision_map->h) {
                    if (getpixel(collision_map, gx, gy) == makecol(0, 0, 0)) {
                        can_move_x = 0;
                        break;
                    }
                }
            }
            if (!can_move_x) break;
        }
        if (can_move_x) {
            joueur.x += 1;
        } else {
            // Collision détectée → pousser le joueur vers la gauche
            int pushed = 0;
            do {
                pushed = 0;
                for (int i = 0; i < joueur.largeur && !pushed; i++) {
                    for (int j = 0; j < joueur.hauteur && !pushed; j++) {
                        int gx = joueur.x + i + decor_scroll;
                        int gy = joueur.y + j;
                        if (gx >= 0 && gx < collision_map->w &&
                            gy >= 0 && gy < collision_map->h) {
                            if (getpixel(collision_map, gx, gy) == makecol(0, 0, 0)) {
                                joueur.x -= 1;
                                pushed = 1;
                            }
                        }
                    }
                }
            } while (pushed && joueur.x > 0);
        }

        // === Collision verticale ===
        int try_y = joueur.y + joueur.dy;
        int can_move_y = 1;
        for (int i = 0; i < joueur.largeur; i++) {
            for (int j = 0; j < joueur.hauteur; j++) {
                int gx = joueur.x + i + decor_scroll;
                int gy = try_y + j;
                if (gx >= 0 && gx < collision_map->w &&
                    gy >= 0 && gy < collision_map->h) {
                    if (getpixel(collision_map, gx, gy) == makecol(0, 0, 0)) {
                        can_move_y = 0;
                        break;
                    }
                }
            }
            if (!can_move_y) break;
        }
        if (can_move_y) {
            joueur.y += joueur.dy;
        } else {
            joueur.dy = 0;
        }

        // Limites verticales
        if (joueur.y < 10) {
            joueur.y = 10;
            joueur.dy = 0;
        }
        if (joueur.y + joueur.hauteur > SCREEN_H - 10) {
            joueur.y = SCREEN_H - joueur.hauteur - 10;
            joueur.dy = 0;
        }

        if (joueur.x + joueur.largeur < 0) {
            allegro_message("GAME OVER - Vous êtes sorti de l'écran !");
            break;
        }

        decor_scroll += DECOR_SCROLL_SPEED;

        // Affichage après 4 secondes
        if (temps_actuel >= 4) afficher_gros = 1;

        clear_bitmap(page);
        blit(fond, page, decor_scroll, 0, 0, 0, SCREEN_W, SCREEN_H);

        // Affichage des roues
        masked_blit(roues[etape_roue], page, 0, 0,
                   roue_x - decor_scroll, roue_y,
                   roues[etape_roue]->w, roues[etape_roue]->h);

        // Gestion du gros (inchangé)
        if (afficher_gros && !gros_collision) {
            int gros_x_ecran = gros_x - decor_scroll;
            draw_sprite(page, img_gros, gros_x_ecran, gros_y);

            if (joueur.x + joueur.largeur > gros_x_ecran &&
                joueur.x < gros_x_ecran + gros_largeur &&
                joueur.y + joueur.hauteur > gros_y &&
                joueur.y < gros_y + gros_hauteur) {
                gros_collision = 1;
            }
        }

        if (gros_collision) {
            facteur_perso += 0.01;
            if (facteur_perso >= 2.0) facteur_perso = 2.0;
        }

        // Affichage du personnage
        BITMAP *sprite = sprite_state ? sprite2 : sprite1;
        int largeur_perso = joueur.largeur * facteur_perso;
        int hauteur_perso = joueur.hauteur * facteur_perso;
        stretch_sprite(page, sprite, joueur.x, joueur.y, largeur_perso, hauteur_perso);

        // Affichage du temps
        char buffer_temps[50];
        sprintf(buffer_temps, "Temps : %d s", temps_actuel);
        textout_ex(page, font, buffer_temps, 10, 10, makecol(255, 255, 255), -1);

        blit(page, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
        rest(20);
    }

    // Nettoyage
    destroy_bitmap(fond);
    destroy_bitmap(collision_map);
    destroy_bitmap(sprite1);
    destroy_bitmap(sprite2);
    destroy_bitmap(img_gros);
    for(int i=0; i<4; i++) destroy_bitmap(roues[i]);
    destroy_bitmap(page);
}

void menu_principal() {
    BITMAP *buffer = create_bitmap(SCREEN_W, SCREEN_H);
    BITMAP *fondmenu = load_bitmap("fondmenu.bmp", NULL);
    BITMAP *marbre = load_bitmap("marbre.bmp", NULL);
    BITMAP *img_volcan = load_bitmap("volcan.bmp", NULL);
    BITMAP *img_montagne = load_bitmap("montagne.bmp", NULL);
    BITMAP *img_mer = load_bitmap("mer.bmp", NULL);

    if (!fondmenu || !marbre || !img_volcan || !img_montagne || !img_mer) {
        allegro_message("Erreur chargement images menu.");
        return;
    }

    char pseudo[MAX_NAME_LENGTH] = "";
    int etape_menu = 0; // 0 = pseudo, 1 = boutons, 2 = maps
    int pseudo_index = 0;

    while (!key[KEY_ESC]) {
        clear(buffer);
        stretch_blit(fondmenu, buffer, 0, 0, fondmenu->w, fondmenu->h, 0, 0, SCREEN_W, SCREEN_H);
        textout_centre_ex(buffer, font, "==== BADLAND ====", SCREEN_W / 2, 30, makecol(255, 215, 0), -1);

        if (etape_menu == 0) {
            // =========== SAISIE PSEUDO ===========
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, 200, 160, 400, 200);
            rect(buffer, 200, 160, 600, 360, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "RENTRER PSEUDO", 400, 180, makecol(0, 0, 0), -1);
            rectfill(buffer, 250, 220, 550, 260, makecol(255, 230, 220));
            rect(buffer, 250, 220, 550, 260, makecol(0, 0, 0));
            textprintf_ex(buffer, font, 260, 235, makecol(0, 0, 0), -1, "%s", pseudo);

            int ok_x1 = 350, ok_y1 = 290, ok_x2 = 450, ok_y2 = 320;
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, ok_x1, ok_y1, ok_x2 - ok_x1, ok_y2 - ok_y1);
            rect(buffer, ok_x1, ok_y1, ok_x2, ok_y2, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "OK", 400, 300, makecol(0, 0, 0), -1);

            if (keypressed()) {
                int key_code = readkey();
                int k = key_code >> 8;
                char ch = key_code & 0xff;
                if (k == KEY_ENTER && pseudo_index > 0) etape_menu = 1;
                else if (k == KEY_BACKSPACE && pseudo_index > 0) pseudo[--pseudo_index] = '\0';
                else if (pseudo_index < MAX_NAME_LENGTH - 1 && ch >= 32 && ch <= 126) {
                    pseudo[pseudo_index++] = ch;
                    pseudo[pseudo_index] = '\0';
                }
            }

            if (mouse_b & 1 &&
                mouse_x >= ok_x1 && mouse_x <= ok_x2 &&
                mouse_y >= ok_y1 && mouse_y <= ok_y2 &&
                pseudo_index > 0) {
                etape_menu = 1;
                rest(200);
            }

        } else if (etape_menu == 1) {
            // ========== BOUTONS NOUVELLE / CHARGER ==========
            textprintf_ex(buffer, font, 10, 40, makecol(255, 255, 255), -1, "Joueur: %s", pseudo);
            textout_centre_ex(buffer, font, "Que veux-tu faire ?", SCREEN_W / 2, 80, makecol(255, 255, 255), -1);

            int btn_w = 250, btn_h = 80;
            int btn_x = (SCREEN_W - btn_w) / 2;
            int btn_y1 = 180;
            int btn_y2 = 300;

            // Fond marbre + texte
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, btn_x, btn_y1, btn_w, btn_h);
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, btn_x, btn_y2, btn_w, btn_h);
            rect(buffer, btn_x, btn_y1, btn_x + btn_w, btn_y1 + btn_h, makecol(0, 0, 0));
            rect(buffer, btn_x, btn_y2, btn_x + btn_w, btn_y2 + btn_h, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "Nouvelle Partie", SCREEN_W / 2, btn_y1 + 30, makecol(0, 0, 0), -1);
            textout_centre_ex(buffer, font, "Charger Partie", SCREEN_W / 2, btn_y2 + 30, makecol(0, 0, 0), -1);

            // ==== BOUTONS RETOUR ET QUITTER ====
            int btn_ctrl_w = 100, btn_ctrl_h = 40;
            int retour_x = 20, retour_y = SCREEN_H - 60;
            int quit_x = SCREEN_W - 120, quit_y = SCREEN_H - 60;

            // Bouton Retour
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, retour_x, retour_y, btn_ctrl_w, btn_ctrl_h);
            rect(buffer, retour_x, retour_y, retour_x + btn_ctrl_w, retour_y + btn_ctrl_h, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "< Retour", retour_x + btn_ctrl_w / 2, retour_y + 12, makecol(0, 0, 0), -1);

            // Bouton Quitter
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, quit_x, quit_y, btn_ctrl_w, btn_ctrl_h);
            rect(buffer, quit_x, quit_y, quit_x + btn_ctrl_w, quit_y + btn_ctrl_h, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "Quitter", quit_x + btn_ctrl_w / 2, quit_y + 12, makecol(0, 0, 0), -1);
            // Gestion clic
            if (mouse_b & 1) {
                rest(200);
                // Nouvelle Partie
                if (mouse_x >= btn_x && mouse_x <= btn_x + btn_w &&
                    mouse_y >= btn_y1 && mouse_y <= btn_y1 + btn_h) {
                    etape_menu = 2;
                }
                // Charger Partie
                else if (mouse_x >= btn_x && mouse_x <= btn_x + btn_w &&
                         mouse_y >= btn_y2 && mouse_y <= btn_y2 + btn_h) {
                    allegro_message("Chargement de partie non disponible.");
                }
                // Retour
                else if (mouse_x >= retour_x && mouse_x <= retour_x + btn_ctrl_w &&
                         mouse_y >= retour_y && mouse_y <= retour_y + btn_ctrl_h) {
                    etape_menu = 0;
                }
                // Quitter
                else if (mouse_x >= quit_x && mouse_x <= quit_x + btn_ctrl_w &&
                         mouse_y >= quit_y && mouse_y <= quit_y + btn_ctrl_h) {
                    break;
                }
            }

        } else if (etape_menu == 2) {
            // ========== CHOIX MAPS (inchangé) ==========
            textprintf_ex(buffer, font, 10, 40, makecol(255, 255, 255), -1, "Joueur: %s", pseudo);
            textout_centre_ex(buffer, font, "Choisis un environnement :", SCREEN_W / 2, 80, makecol(255, 255, 255), -1);

            int cadre_w = 220, cadre_h = 300;
            int img_w = 200, img_h = 280;
            int img_y = 130;
            int space = 40;
            int start_x = (SCREEN_W - (3 * cadre_w + 2 * space)) / 2;

            // VOLCAN
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, start_x, img_y, cadre_w, cadre_h);
            stretch_blit(img_volcan, buffer, 0, 0, img_volcan->w, img_volcan->h,
                         start_x + (cadre_w - img_w) / 2, img_y + (cadre_h - img_h) / 2, img_w, img_h);
            textout_centre_ex(buffer, font, "Terre de Feu", start_x + cadre_w / 2, img_y + cadre_h + 10, makecol(255, 255, 255), -1);

            // MONTAGNE
            int mx = start_x + cadre_w + space;
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, mx, img_y, cadre_w, cadre_h);
            stretch_blit(img_montagne, buffer, 0, 0, img_montagne->w, img_montagne->h,
                         mx + (cadre_w - img_w) / 2, img_y + (cadre_h - img_h) / 2, img_w, img_h);
            textout_centre_ex(buffer, font, "Pics Silencieux", mx + cadre_w / 2, img_y + cadre_h + 10, makecol(255, 255, 255), -1);

            // MER
            int merx = start_x + 2 * (cadre_w + space);
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, merx, img_y, cadre_w, cadre_h);
            stretch_blit(img_mer, buffer, 0, 0, img_mer->w, img_mer->h,
                         merx + (cadre_w - img_w) / 2, img_y + (cadre_h - img_h) / 2, img_w, img_h);
            textout_centre_ex(buffer, font, "Rivages Perdus", merx + cadre_w / 2, img_y + cadre_h + 10, makecol(255, 255, 255), -1);

            // ==== BOUTONS RETOUR ET QUITTER ====
            int btn_ctrl_w = 100, btn_ctrl_h = 40;
            int retour_x = 20, retour_y = SCREEN_H - 60;
            int quit_x = SCREEN_W - 120, quit_y = SCREEN_H - 60;

            // Bouton Retour
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, retour_x, retour_y, btn_ctrl_w, btn_ctrl_h);
            rect(buffer, retour_x, retour_y, retour_x + btn_ctrl_w, retour_y + btn_ctrl_h, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "< Retour", retour_x + btn_ctrl_w / 2, retour_y + 12, makecol(0, 0, 0), -1);

            // Bouton Quitter
            stretch_blit(marbre, buffer, 0, 0, marbre->w, marbre->h, quit_x, quit_y, btn_ctrl_w, btn_ctrl_h);
            rect(buffer, quit_x, quit_y, quit_x + btn_ctrl_w, quit_y + btn_ctrl_h, makecol(0, 0, 0));
            textout_centre_ex(buffer, font, "Quitter", quit_x + btn_ctrl_w / 2, quit_y + 12, makecol(0, 0, 0), -1);

            // CLIC MAP
            if (mouse_b & 1) {
                rest(200);
                if (mouse_x >= start_x && mouse_x <= start_x + cadre_w &&
                    mouse_y >= img_y && mouse_y <= img_y + cadre_h) {
                    jeu_scrolling(pseudo);
                } else if (mouse_x >= mx && mouse_x <= mx + cadre_w &&
                           mouse_y >= img_y && mouse_y <= img_y + cadre_h) {
                    allegro_message("Montagne pas encore disponible !");
                } else if (mouse_x >= merx && mouse_x <= merx + cadre_w &&
                           mouse_y >= img_y && mouse_y <= img_y + cadre_h) {
                    allegro_message("Mer pas encore disponible !");
                }
                // Retour
                if (mouse_x >= retour_x && mouse_x <= retour_x + btn_ctrl_w &&
                    mouse_y >= retour_y && mouse_y <= retour_y + btn_ctrl_h) {
                    etape_menu = 1;
                }
                // Quitter
                if (mouse_x >= quit_x && mouse_x <= quit_x + btn_ctrl_w &&
                    mouse_y >= quit_y && mouse_y <= quit_y + btn_ctrl_h) {
                    break;
                }
            }
        }

        blit(buffer, screen, 0, 0, 0, 0, SCREEN_W, SCREEN_H);
        rest(1);
    }

    destroy_bitmap(fondmenu);
    destroy_bitmap(marbre);
    destroy_bitmap(img_volcan);
    destroy_bitmap(img_montagne);
    destroy_bitmap(img_mer);
    destroy_bitmap(buffer);
}

